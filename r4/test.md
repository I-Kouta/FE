### 令和4年免除

### `テクノロジ系`

---
1.任意のオペランドに対するブール演算Aの結果とブール演算Bの結果が互いに否定の関係にあるとき、AはBの(又は、BはAの)相補演算であるという。排他的論理和の相補演算

<img width="500" alt="" src="./images/演算.png">

- A.**等価演算**

相補演算は、集合演算によって得られる結果が互いにもう一方の演算の補集合となっている関係。AとnotA、X AND YとNOT(X AND Y)のような関係になっているものを指す。  
排他的論理和(XOR)は、2つの入力値が異なれば真、同じであれば偽を返す論理演算。  
排他的論理和の相補演算となるのは、XORの補集合が結果として得られる演算で、適切なのは等価演算となる

---
2.2の補数で表された負数`10101110`の絶対値

- A.**01010010**  
2の補数とは、負数を表現する方法の1つ。ある正の数の2の歩数を求めるには、全てのビットを反転して1を加える

---
3.隣接行列Aで表されるグラフはどれか。隣接行列は、n個の節点から成るグラフのViとVjを結ぶ枝が存在する時は、第i行第j列と第j行第i列の要素が1となり、存在しない時は0となるn行n列の行列である  
(隣接行列A)  
`0110`  
`1001`  
`1001`  
`0110`

<img width="500" alt="" src="./images/隣接行列.png">

- A.**エ**

隣接行列と節点の関係を整理すると次の通り。  

|  |V1|V2|V3|V4|
|--|--|--|--|--|
|V1|0 |1 |1 |0 |
|V2|1 |0 |0 |1 |
|V3|1 |0 |0 |1 |
|V4|0 |1 |1 |0 |

V1 ~ V4の節点のうち結ぶ枝が存在する関係は、「V1とV2」「V1とV3」「V2とV4」「V3とV4」の4つが存在する

---
4.5本のクジがあり、そのうち2本が当たりである。2本同時に引いた時、2本とも当たりである確率

- A.**1 / 10**  
5本のクジから2本の当たりを選ぶので、5C2 = 10通り。2本の当たりクジの両方を選択する組み合わせは、元々2本しか存在しない当たりクジを全て引くので1通り

---
5.逆ポーランド表記法で表現したもの  
`((a + b)(c + d)) / (a - d)`

- A.**ab + cd +* ad - /**  
逆ポーランド表記法(後置表記法)は、演算子を2つの被演算子の右側に記述する表記法。通常の数式`a + b`を逆ポーランド表記法にすると`ab+`となる。  
通常の式を逆ポーランド表記法で表現する時には、通常の式を計算するのと同じ順番で計算式を解くのと同じ要領で変換していく。1度変換した部分はひとまとまりの項として扱うことがポイント<br><br>
1.分子の括弧内の式を変換する :  
`(ab+ * cd+) / (a - d)`  
2.分子の乗算を変換する :  
`(ab+ cd+)* / (a - d)`  
3.分母の式を変換する :  
`(ab+ cd+)* / ad-`  
4.分母の除算を変換する :  
`ab+ cd+* ad- /`

---
6.2分木を入力するためのテキスト表現を規定した。図のように節に番号をつけた時、テキスト表現として適切なもの  
1.(左部分木の節番号又はテキスト表現、節番号、右部分木の節番号又はテキスト表現)と表す  
2.部分木が空の時はxを書く

<img width="300" alt="" src="./images/2分木.png">

- A.**((1, 2, x), 3, (4, 5, 6))**  
木構造の根である"3"の左部分木に着目すると、"2"が節であり左部分木は"1"、右部分木は空になっている。(左, 節, 右)のルールに従うと、この部分木のテキスト表現は`(1, 2, x)`となる。  
次に根"3"の右部分木に着目すると、"5"が節であり左部分木は"4"、右部分木は"6"となっている。この部分木のテキスト表現は`(4, 5, 6)`となる

---
7.与えられた正の整数x0、x1(x0 > x1)の最大公約数を次の手順で決める。x0 = 175、x1 = 77の場合、手順2は何回実行するか。a → bは、AをBに代入することを表す  
[手順]  
1.2 → i  
2.x(i - 2)をx(i - 1)で、割った余剰 → xi  
3.xi = 0ならばx(i - 1)を最大公約数として終了する  
4.i + 1 → iとして、2に戻る

1.iに2を代入する  
`2-1`.x0(175)をx1(77)で割った余りは21 → x2  
3.i = 3として戻る<br><br>
`4-2`.x1(77)をx2(21)で割った余りは14 → x3  
5.i = 4として戻る<br><br>
`6-3`.x2(21)をx3(14)で割った余りは7 → x4  
5.i = 5として戻る<br><br>
`6-4`.x3(14)をx4(7)で割った余りは0 → x5  
7.x5 = 0なので、x4 = 7として終了  
手順2の操作は4回行った

---
8.バブルソートの説明

- A.**隣り合う要素を比較して、大小の順が逆であれば、それらの要素を入れ替えるという操作を繰り返す**  
単純交換法(隣接交換法)は、隣り合う要素同士との比較・交換を繰り返すことで整列を行うアルゴリズム

- ある間隔おきに取り出した要素から成る部分列をそれぞれ整列し、更に間隔を詰めて同様の操作を行い、間隔が1になるまでこれを繰り返す  
シェルソートの説明

- 中間的な基準値を決めて、それよりも大きな値を集めた区分と，小さな値を集めた区分に要素を振り分ける。次に、それぞれの区分の中で同様の操作を繰り返す  
クイックソートの説明

- 未整列の部分を順序木にし、そこから最小値を取り出して整列済の部分に移す。この操作を繰り返して、未整列の部分を縮めていく  
ヒープソートの説明

---
9.異なるn個のデータが昇順に整列された表がある。この表をm個のデータごとのブロックに分割し、各ブロックの最後尾のデータだけを線形探索することによって、目的のデータの存在するブロックを探し出す。次に、当該ブロック内を線形探索して目的のデータを探し出す。この時の平均比較回数を表す式はどれか。mは十分大きく、nはmの倍数とし、目的のデータは必ず表の中に存在するものとする

- A.**(m / 2) + (n / 2m)**

線形探索法は、探索対象データの先頭から1つずつ順番に比較することで目的のデータを探す方法。線形探索法では、n個のデータの中から目的のデータを探す時の平均比較回数は`(n + 1) / 2`回。<br><br>
最初は`n個のデータをm個ごとのブロックに分割した`最後尾のデータのみを探索する。表のデータは昇順に整列されているので、各ブロック最後尾の並びも昇順になっている。この最後尾データの並びに対して「目的のデータ <= 各ブロックの最後尾データ」を順次チェックし、目的のデータが存在するブロックを探す。  
この1回目の探索では、データを1つずつチェックしていくので線形探索の考え方を準用できる。探索するデータ数は`n / m`個なので、目的のデータが存在するブロックが決定するまでの平均比較回数は、  
`(n/m + 1) / 2`(回)<br><br>
2回目は、1回目の探索によって見つけたブロック内を線形探索する。探索する。探索するデータ数はm個なので、目的のデータを見つけるまでの平均比較回数は、  
`(m + 1) / 2`(回)<br><br>
2つの比較回数の合計は、  
`(n/m + 1) / 2 + (m + 1) / 2`(回)<br><br>
mは十分に大きいという条件があるが、`n / m`が十分に大きいとは限らないので定数項の+1は省略不可。  
`(n/m + 1) / 2 + (m + 1) / 2`  
`= {n/m + 1 + m + 1} / 2`  
`= (n/m + m + 2) / 2`  
`= n / 2m + m / 2 + 1`<br><br>
`n / 2m`は、nがmより十分大きい場合に無視できない、定数項は`2 / m`が十分大きいので無視できると考えると、平均比較回数は、  
`n / 2m + m / 2`

---
10.正の整数Mに対して、2つの流れ図に示すアルゴリズムを実行した時、結果xの値が等しくなるようにしたい。aに入れる適切な条件

<img width="500" alt="" src="./images/アルゴリズム.png">

- A.**n > M**  
n = 2, M = 2で、条件を満たさないのでループ先頭に戻る。  
x ← 2, n ← 3  
n = 3, M = 2で、条件を満たす。`x = 2`で左の流れ図と同じ値となる

2つのアルゴリズムで共通のMは正の整数という条件があるので、Mに適当な数値を当てはめることで解答を導く。Mを2として、左のアルゴリズムを解き、結果のxの値が右の式でも出力される条件はどれかを考える

左図 :  
xに1を代入  
変数nを、初期値2から1ずつ減らして、1で終わる  
`x ← 1 * 2 = 2`  
右図 :  
(aの直前)  
x = 1, n = 2

- n < M  
n = 2, M = 2で、条件を満たさないのでループ先頭に戻る。ループ内ではnの値は1ずつ加算されるため、n < Mを満たすことはない

- n > M - 1  
n = 2, M = 2で、条件を満たす。xの値は1で、左の流れ図とは異なる値となる

- n > M + 1  
n = 2, M = 2で、条件を満たさないのでループ先頭に戻る。  
x ← 2, n ← 3  
n = 3, M = 2で、条件を満たさないのでループ先頭に戻る。  
x ← 6, n ← 4  
n = 4, M = 2で、条件を満たすが`x = 6`なので、左の流れ図とは異なる値となる

---
11.表の命令ミックスによるコンピュータの処理性能(単位 : MIPS)

|命令種別|実行速度(ナノ秒)|出現頻度(%)|
|------|--------------|----------|
|整数演算命令|10|50|
|移動命令|40|30|
|分岐命令|40|20|

- A.**40**  
MIPS(*million instructions per second*)は、1秒間の命令実行回数を百万単位で表すCPU性能の指標。2MIPSであれば1秒間に200万回の命令を実行できるという意味。  
3種類の命令を実行するのに必要な実行速度に出現頻度を重み付けすることで、1命令当たりの平均実行時間を求める  
10 * 0.5 + 40 * 0.3 + 40 * 0.2  
= 5 + 12 + 8 = 25ナノ秒  
次に、25ナノ秒の命令を1秒で何回実行できるかを計算する  
1s / 25ナノ秒  
= 0.04 * 10の9乗秒
= 4 * 10の7乗回  
MIPSは命令実行回数を百万単位で表したものなので、 
= 4 * 10の7乗回 / 100万回(10の6乗)  
`= 40MIPS`

---
12.同じ命令セットをもつコンピュータA, Bがある。それぞれのCPUクロック周期、及びあるプログラムを実行したときのCPI(*Cycles Per Instruction*)は表の通り。そのプログラムを実行したとき、コンピュータAの処理時間は、コンピュータBの処理時間の何倍になるか

||CPUクロック周期|CPI|
|-|------------|---|
|コンピュータA|1ナノ秒|4.0|
|コンピュータB|4ナノ秒|0.5|

- A.**2倍**  
CPIは、CPUが1つの命令を実行するのに必要となる平均クロック数を表す。CPUクロック周期はクロックが発生する時間間隔なので、1命令を処理するのに要する時間は、`CPUクロック周期 * CPI`で求めることができる。  
コンピュータA, Bそれぞれの1命令の処理時間は  
A : 1ナノ秒 * 4CPI = 4ナノ秒  
B : 4ナノ秒 * 0.5CPI = 2ナノ秒  
コンピュータAが1命令を処理する時間はコンピュータBの2倍で、同じプログラムを実行すれば、処理時間は2倍になる

---
13.アクセス時間の最も短い記憶装置

- A.**CPUのレジスタ**  
CPUが内部に持つ少量で非常に高速な記憶装置。アキュムレータ、汎用レジスタ、プログラムカウンタ、インデックスレジスタ、命令レジスタ、ステータスレジスタなどがある

コンピュータで使われる記憶装置を高速に動作するものから順に並べると、`レジスタ > キャッシュメモリ > 主記憶 > ディスクキャッシュ > HDD / SSD > 磁気テープ`となる。論理的な位置がCPUに近いほど高速な関係性がある

- CPUの2次キャッシュメモリ  
CPUと主記憶の読み書き速度の差を埋めるために設置される高速な記憶装置

- 磁気ディスク  
主記憶と補助記憶装置の読み書き速度の差を埋めるために設置される記憶装置(ディスクキャッシュ)

---
14.毎分6,000回転、平均位置決め時間20ミリ秒で、1トラック当たりの記憶容量20kバイトの磁気ディスク装置がある。1ブロック4kバイトのデータを1ブロック転送するのに要する平均アクセス時間は何ミリ秒か。磁気ディスクコントローラーのオーバーヘッドは無視できるものとし、1kバイト = 1,000バイトとする

- **27ミリ秒**

磁気ディスクのアクセス時間は以下の式で求められる。  
`平均シーク時間 + 平均回転待ち時間 + データ転送時間`<br><br>
・平均位置決め時間(シークタイム) :  
磁気ディスクのヘッドが、目的のデータが保存されている位置まで移動するのにかかる時間の平均。この問題では`20ミリ秒`で定められている<br><br>
・平均回転待ち時間(サーチタイム) :  
ヘッドの移動が完了した後、読み出すレコードの先頭が磁気ヘッドの位置まで磁気ディスクが回転してくるのを待つ時間の平均。ディスクが1回転するのにかかる時間の半分が平気回転待ち時間となる<br><br>
・データ転送時間 :  
目的のデータを読み出すのに要する時間<br><br>
6,000回転 / minの磁気ディスクが1回転するのにかかる時間は、  
`60秒 / 6,000 = 10ミリ秒`<br><br>
平均回転待ち時間は、ディスクが1回転するのにかかる時間の半分なので、`5ミリ秒`<br><br>
データ転送速度は、1回転(1トラック)20kバイトなので、4kバイトを読み取るのにかかる時間は、  
10ミリ秒 * (4k / 20k) = `2ミリ秒`<br><br>
総和は、20 + 5 + 2 = `27ミリ秒`

---
15.ジョブの多重度が1で、到着順にジョブが実行されるシステムにおいて、表に示す状態のジョブA ~ Cを処理する時、ジョブCが到着してから実行が終了するまでのターンアラウンドタイムは何秒か。OSのオーバーヘッドは考慮しないものとする(単位 : 秒)

|ジョブ|到着時刻|処理時間(単独実行時)|
|-----|------|-----------------|
|A    |0     |5                |
|B    |2     |6                |
|C    |3     |3                |

- A.**11**  
ターンアラウンドタイムは、利用者がシステムに処理要求を開始してから、全ての結果を受け取るまでに要する時間のこと。  
ジョブCの到着は処理開始時点から3秒後、完了は処理開始時点から14秒後なので、ターンアラウンドタイムは11秒

<img width="500" alt="" src="./images/ターンアラウンドタイム.png">

---
16.3層クライアントサーバシステムの各層の役割

- A.**ファンクション層は、データを加工してプレゼンテーション層に返信する**  
データベースアクセス層から返された結果を、ユーザに分かるように加工してからプレゼンテーション層に返す

3層クライアントサーバシステムは、システムをクライアント(利用者)に近い側から「プレゼンテーション層」「ファンクション層」「データベースアクセス層」の3つに論理的に分離したシステムモデル<br><br>
・プレゼンテーション層 :  
クライアントからデータを入力を受け付けたり、問合せ結果を表示するなどユーザの入出力を担う層<br><br>
・ファンクション層 :  
サーバ側でクライアントの問合せを中継したり、データ層から取得したデータを加工してクライアントに送ったりとデータの変換処理を担う層<br><br>
・データベースアクセス層(データ層) :  
DBへのアクセス・保管などDB処理を集中的に担う層

<img width="400" alt="" src="./images/3層クライアントサーバシステム.png">

- データベースアクセス層は、データを加工してプレゼンテーション層に返信する  
データ加工はファンクション層が行う

- ファンクション層は、データベースアクセス層で組み立てられたSQL文を解釈する  
SQL文の解釈はデータベースアクセス層の役割

- プレゼンテーション層は、データベースアクセス層にSQL文で問い合わせる  
3層C / Sシステムではプレゼンテーション層からデータベースアクセス層に直接的に要求することはない。SQL文を組立てデータベースアクセス層に問合せを行うのはファンクション層の役割

---
17.仮想記憶管理におけるページ置換えアルゴリズムとしてLRU方式を採用する。主記憶のページ枠が、4000, 5000, 6000, 7000番地(いずれも16進数)の4ページ分で、プログラムが参照するページ番号の順が、1 → 2 → 3 → 4 → 2 → 5 → 3 → 1 → 6 → 5 → 4の時、最後の参照ページ4は何番地にページインされているか。最初の1 → 2 → 3 → 4の参照で、それぞれのページは4000, 5000, 6000, 7000番地にページインされるものとする

- A.**6000**

LRU(*Least Recently Used*)は、置換え対象の中で最後に参照されてからの時間が最も長いページを置換え対象とするアルゴリズム。番号は、左から4000, 5000, 6000, 7000番地とする

1.最初の1から4までは設問の指示通りページインする  
`1, 2, 3, 4`<br><br>
2.2は主記憶に存在するのでページアウトは発生しない  
`1, 2, 3, 4`<br><br>
3.5は主記憶に存在しないのでページ置換えが必要。この時点で最も昔に参照されたページは1なので、1をページアウトしその位置に5をページインする  
`5, 2, 3, 4`<br><br>
4.3は主記憶に存在するのでページアウトは発生しない  
`5, 2, 3, 4`<br><br>
5.1は主記憶に存在しないのでページ置換えが必要。この時点で最も昔に参照されたページは4なので、4をページアウトしその位置に1をページインする  
`5, 2, 3, 1`<br><br>
6.6は主記憶に存在しないのでページ置換えが必要。この時点で最も昔に参照されたページは2なので、2をページアウトしその位置に6をページインする  
`5, 6, 3, 1`<br><br>
7.5は主記憶に存在するのでページアウトは発生しない  
`5, 6, 3, 1`<br><br>
8.4は主記憶に存在しないのでページ置換えが必要。この時点で最も昔に参照されたページは3なので、3をページアウトしその位置に4をページインする  
`5, 6, 4, 1`<br><br>
操作終了時点でページ4は左から3番目の6000番地にページインしている

---
18.仮想記憶におけるページ置換えアルゴリズムの1つのLRUを説明した記述

- A.**最も長い間参照されていないページを追い出す**  
置換え対象のうち最後に参照されてからの時間が最も長いもの、つまり最も長い時間使用されていないものを置換え対象とするアルゴリズム

- あらかじめ設定されている優先度が最も低いページを追い出す  
静的優先度順のアルゴリズムは、ページ置換えアルゴリズムとしては存在しない。優先度の高いページが主記憶に残り続けることで、使用できる記憶領域が少なくなってしまうため

- 主記憶に存在している時間が最も長いページを追い出す  
FIFO(*First in First out* : 先入れ先出し)の説明

- 主記憶に存在している時間が最も短いページを追い出す  
LIFO(*Last in First out* : 後入れ先出し)の説明

---
19.Hadoop(ハドゥープ)の説明

- A.**大規模なデータセットを分散処理するためのソフトウェアライブラリ**  
大規模なデータの分散処理基盤を提供するソフトウェアライブラリ

ペタバイト級の大規模データの蓄積・処理の分散処理を実現するミドルウェア。Googleが論文として発表した分散処理フレームワーク「*MapReduce*」および分散ファイルシステム「*Google File System*」を基盤技術に、オープンソースとしてJavaで実装したもの。分散ファイルシステムのHDFS(*Hadoop Distributed File System*)と、分散処理のフレームワークである*Hadoop MapReduce*の2つから構成される

- JavaEE仕様に準拠したアプリケーションサーバ  
WildFlyの説明

- LinuxやWindowsなどの様々なプラットフォーム上で動作するWebサーバ  
ApacheやNginxなどの説明

- 機能の豊富さが特徴のRDBMS  
PostgreSQLなどの説明

---
20.`0xABCD1234`をリトルエンディアンで4バイトのメモリで配置したものはどれか。0 ~ +3はバイトアドレスのオフセット値

- A.(以下回答)

|0     |+1    |+2    |+3    |
|------|------|------|------|
|**34**|**12**|**AB**|**CD**|

エンディアンは、バイト単位のデータをメモリに記録するときの方式で、リトルエンディアンは、記録するデータの下位バイトから順番に、メモリのアドレスを若い方に格納していく方式。  
ビッグエンディアンは、データの上位バイトから順番に並べていく方式(下図)。  
ビッグエンディアンは人間がデータの並びを認識しやすい、リトルエンディアンはコンピュータがデータを処理しやすいという特徴がある

|0 |+1|+2|+3|
|--|--|--|--|
|AB|CD|12|34|

---
21.ワンチップマイコンの内蔵メモリとしてフラッシュメモリが採用されている理由

- A.**マイコン出荷後もソフトウェアの書換えが可能である**  
組込みシステムの内蔵メモリとして従来からあるマスクROMはデータ保護ができる反面、出荷後に書換えはできず、アップデートにはROMの交換など莫大なコストを要することになる。  
フラッシュメモリの登場により、機器のフタを開けなくてもユーザが電子的な操作だけでデータ書換えができるISP(*In-System Programming*)が可能になり、出荷後のアップデートが以前よりも容易に行えるようになっている
