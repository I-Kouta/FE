### 9.1 データベース方式

---
1.関係モデルとその実装である関係DBの対応に関する記述

- A.**関係は、表に対応付けられる**  
関係モデルはデータの関係を数学的な集合論と述語論によって表現するモデルで、関係DBは関係モデルをコンピュータ上で実装したもの

<img width="500" alt="" src="./images/関係モデル.png">

- 属性も列も、左から右に順序付けられる  
関係モデルは数学的モデルなので属性には順序の概念はないが、関係DBはデータを2次元の表で管理するため列順が生じる

- タプルも行も、ともに重複しない  
関係モデルのタプルは重複を許さないが、関係DBの場合は関係演算の結果によっては重複行が生じることがある

- 定義域(ドメイン)は、文字型又は文字列型に対応付けられる  
値の取り得る範囲・形式を制限するデータ型に対応する

---
2.関係モデルの属性に関する説明

- A.**関係内の属性の並び順に意味はなく、順番を入れ替えても同じ関係である**  
関係DBにおいて、関係は表、属性は列(カラム)、組(タプル)は行(レコード)に対応する。属性の並び・組の並びに意味はない。並び順が変わっても関係は変わらない

- 関係内の属性の定義域は重複してはならない  
属性が取り得る値の集合のことで、データ型と同じ意味でドメインとも呼ぶ。関係内の2つの属性に整数型などの同じ定義域を設定することを考えると、定義域の重複は問題にならない

- 関係内の2つ以上の属性に、同じ名前を付けることができる  
属性に付ける名前は関係内で一意でなければならない

- 名前をもたない属性を定義することができる  
属性には名前を付けなければならない

---
5.DBMSにおいて、スキーマ(*schema*)を決める機能

- A.**定義機能**  
データの内容・論理構造、記憶形式や編成などDBの構造を記述したもの

- 機密保護機能  
ユーザ認証、アクセス権限、利用ログの記録、暗号化などによってデータを安全に保つ機能

- 障害回復機能  
ロールバック、ロールフォワード、チェックポイント、更新前 / 更新後ログの記録などによってDBを生涯から回復する機能

- 保全機能  
排他制御や参照制約、表制約などによってデータの完全性を保つ機能

---
6.DBMSが3層スキーマアーキテクチャを採用する目的

- A.**データの物理的な格納構造を変更しても、アプリケーションプログラムに影響が及ばないようにする**  
`概念スキーマ` : DB化対象の業務とデータの内容を論理的な構造として記述したもの。関係モデルではER図の作成、表定義、表の正規化が該当する  
`外部スキーマ` : データの利用者からの見方を記述したもの。SQLのビューが外部スキーマに該当する  
`内部スキーマ` : データを記憶装置上にどのような形式で格納するかを記述したもの。ファイル編成やインデックスの設定などが該当する

- 関係演算によって元の表から新たな表を導出し、それが実在しているように見せる  
ビューの目的

- 対話的に使われるSQL文を、アプリケーションプログラムからも使えるようにする  
カーソル操作の目的

- プログラム言語を限定して、アプリケーションプログラムとDBMSを緊密に結合する  
緊密ではなく、分離する目的がある

---
7.DBMSが受け付けたクエリを実行するまでの処理の流れにおいて、該当する処理の組み合わせ

<img width="500" alt="" src="./images/クエリ.png">

- A.**構文解析, 最適化, コード生成**  
`構文解析` : パーサが受け付けたSQLクエリを解析し、内容を解釈する  
`最適化` : クエリを最も効率よく実行できる方法を検討し決定する  
`コード生成` : 決定された方法でDBにアクセスするためのコードを生成する

---
8.SQL文を実行する際に、効率が良いと考えられるアクセス経路を選択する関係DB管理システム(RDBMS)の機能

- A.**オプティマイザ**(*Optimizer*)  
SQL文に対する結果は1つでも、RDBMSの内部ではインデックスの使用有無、結合の順番などからいくつかの実行方法が考えられる。SQL文を処理するために考えられる実行計画を全て検証し、最も効率が良いと予想される実行計画の決定を行う。更に最適な実行方法を決める基準には、アクセスパスに対して付けられた優先順位をもとに選択する`ルールベース`、アクセスする表やインデックスの統計情報をもとに見積もられたコストをもとに計算する`コストベース`の2種類がある

---
9.関係DB(*RelationalDataBase*)のデータ構造の説明

- A.**データを2次元の表によって表現する**  
データ構造を平坦な2次元の表で定義する。表をテーブル、行をレコード(タプル)、列をカラム(フィールド)と呼び、複数の表の関連は主キー同士または主キーと外部キーによって行われる

- 親レコードと子レコードをポインタで結合する  
木構造を使ってデータ構造を表す階層型DBの説明

- タグを用いてデータの構造と意味を表す  
SGMLやHTMLなどのマークアップ言語の説明

- データと手続を一体化(カプセル化)してもつ  
オブジェクト指向におけるクラスの説明

---
11.関係DBの説明

- A.**データを表として表現する。表間は相互の表中の列の値を用いて関連付けられる**

- 属性単位に、属性値とその値をもつレコード格納位置を組にして表現する。索引として利用される  
DBのアクセス効率を向上させるために使用される、インデックスの説明

- レコード間の関係を、ポインタを用いたデータ構造で表現する。木構造の表現に制限される  
階層型DBの説明

- レコード間の関係を、リンクを用いたデータ構造で表現する。木構造や網構造も表現できる  
ネットワーク型DBの説明

---
13.DBを記録媒体にどのように格納するか記述したもの

- A.**内部スキーマ**  
データを記憶装置上にどのような形式で格納するかを記述したもの。`ファイル編成やインデックスの設定`などが該当する

- 概念スキーマ  
DB化対象の業務とデータの内容を論理的な構造として記述したもの。関係モデルではER図の作成、表定義、表の正規化が該当する

- 外部スキーマ(サブスキーマ)  
データの利用者からの見方を記述したもの。SQLのビューが外部スキーマに該当する

---
14.関係データモデルにおいて、属性が取り得る値の集合を意味する用語

- A.**定義域**(*domain*)  
属性がもつデータ型と同じ意味。基本となる整数、文字列、日付等の他に列挙値や非負の整数などを定義域として設定できる。独自のドメインを定義するにはSQLの`create domain`文を使う

- 関係(リレーション)  
表同士の関連を意味する

- 実現値  
レコードや表に格納される個々のデータを意味する

- タプル(組)  
リレーショナルDBにおけるレコード・行を意味する

---
15.データモデルにおいて、データの関係を木構造で表すもの

- A.**階層モデル**  
木構造(階層構造)で表現する

- ERモデル  
実体(エンティティ)と実体のもつ属性(アトリビュート)、実体間の関連(リレーションシップ)を実現する図

- 関係モデル  
データを2次元の表で実現する

- ネットワークモデル  
親(子)レコードがそれぞれ複数のリンクをもち、多対多の関係を網状に表現できる

### 9.2 データベース設計

---
1.関係DBの主キーの性質

- A.**1つの表の中に、主キーの値が同じ行が複数存在することはない**  
一意性制約を説明している。表中の行を一意に識別できる性質を保持するため、主キーの値が同じ行が複数存在することはできない。主キーには非NULL制約も課される

- 主キーとした列に対して検索条件を指定しなければ、行の検索はできない  
主キー以外の列の値を使った検索もできる

- 数値型の列を主キーに指定すると、その列は算術演算の対象としては使えない  
主キー列を集計関数等で計算の対象とすることもできる

- 複数の列からなる主キーを構成することはできない  
1つの属性だけで行の特定ができない場合、複数の属性を組み合わせて複合主キーとすることがある

---
5.関係"注文記録"の属性間に関数従属性があり、それに基づいて第3正規形まで正規化を行って、"商品"、"顧客"、"注文"、"注文明細"の各関係に分解した。関係"注文明細"として、適切なものはどれか。{X, Y} は、属性XとYの組みを表し、X → Yは、XがYを関数的に決定することを表す。実線の下線は主キーを表す  
`注文記録` {注文記録, 注文日, 顧客番号, 顧客名, 商品番号, 商品名, 数量, 販売単価}  
`関係従属性`  
注文番号 → 注文日  
注文番号 → 顧客番号  
顧客番号 → 顧客名  
{注文番号, 商品番号} → 数量  
{注文番号, 商品番号} → 販売単価  
商品番号 → 商品名

- A.**注文明細(<u>注文番号</u>, <u>顧客番号</u>, <u>商品番号</u>, 顧客名, 数量, 販売単価)**

---
6.どこまで正規化された表か

|従業員番号|氏名|入社年|職位|職位手当|
|--------|---|------|---|-------|
|12345|情報 太郎|1991|部長|90,000|
|12346|処理 太郎|2005|課長|50,000|
|12347|技術 三郎|2007|課長|50,000|

- A.**第2正規形**  
主キーの一部だけで一意に決まる属性を別表に分離した状態(部分関数従属がない)。主キーは単一の属性値で部分関数従属がないため満たしている

- 第1正規形  
各データのキーが設定され、属性に繰り返し項目がない状態。属性の値として繰り返す項目がないため満たしている。

- 第3正規形  
主キー以外の属性によって一意に決まる属性を別表に分離した状態(推移関数従属が存在しない)。職位が決まれば職位手当は一意に決まるという従属関係があり、この関係を別表に分離しなければならない

---
9.データ項目の命名規約を設ける場合、次の命名規則だけでは回避できない事象  
1.データ項目名の末尾には必ず"名"、"コード"、"数"、"金額"、"年月日"などの区分語を付与し、区分語ごとに定めたデータ型にする  
2.データ項目名と意味を登録した辞書を作成し、異音同義語や同音異義語が発生しないようにする

- A.**データ項目"受注金額"の取り得る値の範囲がテーブルによって異なる**  
データ型は命名規則に定義されているが、値の範囲は定義されていないので回避できない

- データ項目"受信年月日"のデータ型として、日付型と文字列型が混在する  
データ項目の区分の末尾には必ず区分語を付与し、区分ごとに定めたデータ型にするので、末尾が"年月日"のデータ型は常に同じになる

- データ項目"賞与金額"と同じ意味で"ボーナス金額"というデータ項目がある  
辞書の作成によって異音同義語や同音意義語が発生しないようにする

- データ項目"取引先"が"取引先コード"か"取引先名"か判別できない  
データ項目名の末尾の規則より、取引先というデータ項目は存在し得ない

---
10.SQL文において、`foreign key`と`references`を用いて指定する制約

- A.**参照制約**  
`foreign key 列リスト references 親テーブル(列リスト)`  
外部キーを持つ表にレコードを追加する場合に、外部キー列の値は参照先の表の主キーとして存在するものでなければならない、また、別表から主キーの値を参照されている行は削除できないという制限を課す制約。関係DBの整合性を保つために設定される

- キー制約  
`primary`句や`foreign key`句で指定する

- 検査制約  
`check`句で指定する

- 表明  
整合性制約の一種で`create assertion`句で指定する

---
11.UMLを用いて表した図のデータモデルの解釈

<img width="400" alt="" src="./images/データモデル.png">

- A.**社員は事業部に所属できる**  
事業部クラスと部門クラスは汎化 - 特化関係にあり、事業部クラスは部門クラスを特化させた存在。事業部は部門の一種で、親クラスの部門に社員が所属できるなら、子クラスの事業部にも社員が所属できる

- 事業部以外の部門が部門を管理できる  
部門クラスとの間は"管理する"の関連名が付いているのは事業部 → 部門のみなので、事業部のみが部門を管理できる

- 所属する社員がいない部門が存在する  
部門から見た社員の多重度は1以上なので社員が所属しない部門は存在しない

- 部門は、いずれかの事業部が管理している  
部門から見た事業部の多重度は0か1のどちらかなので事業部に管理されていない部門も存在し得る

---
12.属性aの値が決まれば属性bの値が一意に定まることを、a → bで表す。社員番号が決まれば社員名が一意に定まるということの表現は、社員番号 → 社員名である。この表記法に基づいて、図のような関係が成立している属性 a ~ j を、関係DB上の3つのテーブルで定義する組合せ

<img width="400" alt="" src="./images/テーブル.png">

- A.**テーブル1{a, b, c, d, e}**
- A.**テーブル2{b, f, g, h}**
- A.**テーブル3{e, i, j}**  
以下2つの推移的関数従属がある  
a → b → {f, g, h}  
a → e → {i, j}  
表間を関連づけるb, eを別表に移す
