### 9.1 データベース方式

---
1.関係モデルとその実装である関係DBの対応に関する記述

- A.**関係は、表に対応付けられる**  
関係モデルはデータの関係を数学的な集合論と述語論によって表現するモデルで、関係DBは関係モデルをコンピュータ上で実装したもの

<img width="500" alt="" src="./images/関係モデル.png">

- 属性も列も、左から右に順序付けられる  
関係モデルは数学的モデルなので属性には順序の概念はないが、関係DBはデータを2次元の表で管理するため列順が生じる

- タプルも行も、ともに重複しない  
関係モデルのタプルは重複を許さないが、関係DBの場合は関係演算の結果によっては重複行が生じることがある

- 定義域(ドメイン)は、文字型又は文字列型に対応付けられる  
値の取り得る範囲・形式を制限するデータ型に対応する

---
2.関係モデルの属性に関する説明

- A.**関係内の属性の並び順に意味はなく、順番を入れ替えても同じ関係である**  
関係DBにおいて、関係は表、属性は列(カラム)、組(タプル)は行(レコード)に対応する。属性の並び・組の並びに意味はない。並び順が変わっても関係は変わらない

- 関係内の属性の定義域は重複してはならない  
属性が取り得る値の集合のことで、データ型と同じ意味でドメインとも呼ぶ。関係内の2つの属性に整数型などの同じ定義域を設定することを考えると、定義域の重複は問題にならない

- 関係内の2つ以上の属性に、同じ名前を付けることができる  
属性に付ける名前は関係内で一意でなければならない

- 名前をもたない属性を定義することができる  
属性には名前を付けなければならない

---
5.DBMSにおいて、スキーマ(*schema*)を決める機能

- A.**定義機能**  
データの内容・論理構造、記憶形式や編成などDBの構造を記述したもの

- 機密保護機能  
ユーザ認証、アクセス権限、利用ログの記録、暗号化などによってデータを安全に保つ機能

- 障害回復機能  
ロールバック、ロールフォワード、チェックポイント、更新前 / 更新後ログの記録などによってDBを生涯から回復する機能

- 保全機能  
排他制御や参照制約、表制約などによってデータの完全性を保つ機能

---
6.DBMSが3層スキーマアーキテクチャを採用する目的

- A.**データの物理的な格納構造を変更しても、アプリケーションプログラムに影響が及ばないようにする**  
`概念スキーマ` : DB化対象の業務とデータの内容を論理的な構造として記述したもの。関係モデルではER図の作成、表定義、表の正規化が該当する  
`外部スキーマ` : データの利用者からの見方を記述したもの。SQLのビューが外部スキーマに該当する  
`内部スキーマ` : データを記憶装置上にどのような形式で格納するかを記述したもの。ファイル編成やインデックスの設定などが該当する

- 関係演算によって元の表から新たな表を導出し、それが実在しているように見せる  
ビューの目的

- 対話的に使われるSQL文を、アプリケーションプログラムからも使えるようにする  
カーソル操作の目的

- プログラム言語を限定して、アプリケーションプログラムとDBMSを緊密に結合する  
緊密ではなく、分離する目的がある

---
7.DBMSが受け付けたクエリを実行するまでの処理の流れにおいて、該当する処理の組み合わせ

<img width="500" alt="" src="./images/クエリ.png">

- A.**構文解析, 最適化, コード生成**  
`構文解析` : パーサが受け付けたSQLクエリを解析し、内容を解釈する  
`最適化` : クエリを最も効率よく実行できる方法を検討し決定する  
`コード生成` : 決定された方法でDBにアクセスするためのコードを生成する

---
8.SQL文を実行する際に、効率が良いと考えられるアクセス経路を選択する関係DB管理システム(RDBMS)の機能

- A.**オプティマイザ**(*Optimizer*)  
SQL文に対する結果は1つでも、RDBMSの内部ではインデックスの使用有無、結合の順番などからいくつかの実行方法が考えられる。SQL文を処理するために考えられる実行計画を全て検証し、最も効率が良いと予想される実行計画の決定を行う。更に最適な実行方法を決める基準には、アクセスパスに対して付けられた優先順位をもとに選択する`ルールベース`、アクセスする表やインデックスの統計情報をもとに見積もられたコストをもとに計算する`コストベース`の2種類がある

---
9.関係DB(*RelationalDataBase*)のデータ構造の説明

- A.**データを2次元の表によって表現する**  
データ構造を平坦な2次元の表で定義する。表をテーブル、行をレコード(タプル)、列をカラム(フィールド)と呼び、複数の表の関連は主キー同士または主キーと外部キーによって行われる

- 親レコードと子レコードをポインタで結合する  
木構造を使ってデータ構造を表す階層型DBの説明

- タグを用いてデータの構造と意味を表す  
SGMLやHTMLなどのマークアップ言語の説明

- データと手続を一体化(カプセル化)してもつ  
オブジェクト指向におけるクラスの説明

---
11.関係DBの説明

- A.**データを表として表現する。表間は相互の表中の列の値を用いて関連付けられる**

- 属性単位に、属性値とその値をもつレコード格納位置を組にして表現する。索引として利用される  
DBのアクセス効率を向上させるために使用される、インデックスの説明

- レコード間の関係を、ポインタを用いたデータ構造で表現する。木構造の表現に制限される  
階層型DBの説明

- レコード間の関係を、リンクを用いたデータ構造で表現する。木構造や網構造も表現できる  
ネットワーク型DBの説明

---
13.DBを記録媒体にどのように格納するか記述したもの

- A.**内部スキーマ**  
データを記憶装置上にどのような形式で格納するかを記述したもの。`ファイル編成やインデックスの設定`などが該当する

- 概念スキーマ  
DB化対象の業務とデータの内容を論理的な構造として記述したもの。関係モデルではER図の作成、表定義、表の正規化が該当する

- 外部スキーマ(サブスキーマ)  
データの利用者からの見方を記述したもの。SQLのビューが外部スキーマに該当する

---
14.関係データモデルにおいて、属性が取り得る値の集合を意味する用語

- A.**定義域**(*domain*)  
属性がもつデータ型と同じ意味。基本となる整数、文字列、日付等の他に列挙値や非負の整数などを定義域として設定できる。独自のドメインを定義するにはSQLの`create domain`文を使う

- 関係(リレーション)  
表同士の関連を意味する

- 実現値  
レコードや表に格納される個々のデータを意味する

- タプル(組)  
リレーショナルDBにおけるレコード・行を意味する

---
15.データモデルにおいて、データの関係を木構造で表すもの

- A.**階層モデル**  
木構造(階層構造)で表現する

- ERモデル  
実体(エンティティ)と実体のもつ属性(アトリビュート)、実体間の関連(リレーションシップ)を実現する図

- 関係モデル  
データを2次元の表で実現する

- ネットワークモデル  
親(子)レコードがそれぞれ複数のリンクをもち、多対多の関係を網状に表現できる

### 9.2 データベース設計

---
1.関係DBの主キーの性質

- A.**1つの表の中に、主キーの値が同じ行が複数存在することはない**  
一意性制約を説明している。表中の行を一意に識別できる性質を保持するため、主キーの値が同じ行が複数存在することはできない。主キーには非NULL制約も課される

- 主キーとした列に対して検索条件を指定しなければ、行の検索はできない  
主キー以外の列の値を使った検索もできる

- 数値型の列を主キーに指定すると、その列は算術演算の対象としては使えない  
主キー列を集計関数等で計算の対象とすることもできる

- 複数の列からなる主キーを構成することはできない  
1つの属性だけで行の特定ができない場合、複数の属性を組み合わせて複合主キーとすることがある

---
5.関係"注文記録"の属性間に関数従属性があり、それに基づいて第3正規形まで正規化を行って、"商品"、"顧客"、"注文"、"注文明細"の各関係に分解した。関係"注文明細"として、適切なものはどれか。{X, Y} は、属性XとYの組みを表し、X → Yは、XがYを関数的に決定することを表す。実線の下線は主キーを表す  
`注文記録` {注文記録, 注文日, 顧客番号, 顧客名, 商品番号, 商品名, 数量, 販売単価}  
`関係従属性`  
注文番号 → 注文日  
注文番号 → 顧客番号  
顧客番号 → 顧客名  
{注文番号, 商品番号} → 数量  
{注文番号, 商品番号} → 販売単価  
商品番号 → 商品名

- A.**注文明細(<u>注文番号</u>, <u>商品番号</u>, 数量, 販売単価)**

---
6.どこまで正規化された表か

|従業員番号|氏名|入社年|職位|職位手当|
|--------|---|------|---|-------|
|12345|情報 太郎|1991|部長|90,000|
|12346|処理 太郎|2005|課長|50,000|
|12347|技術 三郎|2007|課長|50,000|

- A.**第2正規形**  
主キーの一部だけで一意に決まる属性を別表に分離した状態(部分関数従属がない)。主キーは単一の属性値で部分関数従属がないため満たしている

- 第1正規形  
各データのキーが設定され、属性に繰り返し項目がない状態。属性の値として繰り返す項目がないため満たしている。

- 第3正規形  
主キー以外の属性によって一意に決まる属性を別表に分離した状態(推移関数従属が存在しない)。職位が決まれば職位手当は一意に決まるという従属関係があり、この関係を別表に分離しなければならない

---
9.データ項目の命名規約を設ける場合、次の命名規則だけでは回避できない事象  
1.データ項目名の末尾には必ず"名"、"コード"、"数"、"金額"、"年月日"などの区分語を付与し、区分語ごとに定めたデータ型にする  
2.データ項目名と意味を登録した辞書を作成し、異音同義語や同音異義語が発生しないようにする

- A.**データ項目"受注金額"の取り得る値の範囲がテーブルによって異なる**  
データ型は命名規則に定義されているが、値の範囲は定義されていないので回避できない

- データ項目"受信年月日"のデータ型として、日付型と文字列型が混在する  
データ項目の区分の末尾には必ず区分語を付与し、区分ごとに定めたデータ型にするので、末尾が"年月日"のデータ型は常に同じになる

- データ項目"賞与金額"と同じ意味で"ボーナス金額"というデータ項目がある  
辞書の作成によって異音同義語や同音意義語が発生しないようにする

- データ項目"取引先"が"取引先コード"か"取引先名"か判別できない  
データ項目名の末尾の規則より、取引先というデータ項目は存在し得ない

---
10.SQL文において、`foreign key`と`references`を用いて指定する制約

- A.**参照制約**  
`foreign key 列リスト references 親テーブル(列リスト)`  
外部キーを持つ表にレコードを追加する場合に、外部キー列の値は参照先の表の主キーとして存在するものでなければならない、また、別表から主キーの値を参照されている行は削除できないという制限を課す制約。関係DBの整合性を保つために設定される

- キー制約  
`primary`句や`foreign key`句で指定する

- 検査制約  
`check`句で指定する

- 表明  
整合性制約の一種で`create assertion`句で指定する

---
11.UMLを用いて表した図のデータモデルの解釈

<img width="400" alt="" src="./images/データモデル.png">

- A.**社員は事業部に所属できる**  
事業部クラスと部門クラスは汎化 - 特化関係にあり、事業部クラスは部門クラスを特化させた存在。事業部は部門の一種で、親クラスの部門に社員が所属できるなら、子クラスの事業部にも社員が所属できる

- 事業部以外の部門が部門を管理できる  
部門クラスとの間は"管理する"の関連名が付いているのは事業部 → 部門のみなので、事業部のみが部門を管理できる

- 所属する社員がいない部門が存在する  
部門から見た社員の多重度は1以上なので社員が所属しない部門は存在しない

- 部門は、いずれかの事業部が管理している  
部門から見た事業部の多重度は0か1のどちらかなので事業部に管理されていない部門も存在し得る

---
12.属性aの値が決まれば属性bの値が一意に定まることを、a → bで表す。社員番号が決まれば社員名が一意に定まるということの表現は、社員番号 → 社員名である。この表記法に基づいて、図のような関係が成立している属性 a ~ j を、関係DB上の3つのテーブルで定義する組合せ

<img width="400" alt="" src="./images/テーブル.png">

- A.**テーブル1{a, b, c, d, e}**
- A.**テーブル2{b, f, g, h}**
- A.**テーブル3{e, i, j}**  
以下2つの推移的関数従属がある  
a → b → {f, g, h}  
a → e → {i, j}  
表間を関連づけるb, eを別表に移す

---
13.図のデータモデルを3つの表で実装する。"A社への売上50,000円を2017年4月4日に現金勘定に計上した"ことを記録する"移動"表のa, bの適切な組み合わせ

<img width="500" alt="" src="./images/取引表.png">

- A.**a : 510**
- A.**b : 借方**  
移動表の取引番号より、それぞれの取引について2件ずつレコードが記録されており、1つの取引において"812 : 旅費(借方)と510 : 現金(貸方)"が一対で登録されている。既に"208 : 売上(貸方)"のレコードが登録されているので、もう片方が該当する

---
14.ER図に関する記述

- A.**業務で扱う情報をエンティティ及びエンティテイ間のリレーションシップとして表現する**  
関係DBの概念モデル設計によく利用されるが、記法自体は関係モデルに限らず任意のオブジェクトとその関連の記述が可能

- 関係DBの表として実装することを前提に表現する  
関係DB用のモデリングだけに限らず、任意のオブジェクト(実体)とその関連を記述するのに使用可能

- データの生成から消滅に至るデータ操作を表現する  
DFD(*Data Flow Diagram*)に関する記述

- リレーションシップは、業務上の手順を表現する  
実体がもつ関連を表現する

---
16.関係DBにおいて、外部キーを定義する目的

- A.**関係する相互のテーブルにおいて、レコード間の参照一貫性が維持される制約をもたせる**  
関係DBの2つのテーブル間の参照整合性を保つための制約。SQLでは設定する属性に対して`foreign key`句を指定する。正規化された表同士を外部キーで結合することでデータの一貫性・正当性を保つことができる

---
20.RDBMSにおけるスキーマ(*Schema*)の説明

- A.**データの性質、形式、ほかのデータとの関連などのデータ定義の集合である**  
データの内容・論理構造・記述記憶や編成などDBの構造を記述したもの。概念スキーマ / 外部スキーマ / 内部スキーマの3グループに分けられている(3層スキーマアーキテクチャ)

- 実表ではない、利用者の視点による仮想的な表である  
ビューの説明

- データの挿入、更新、削除、検索などのデータベース操作の総称である  
SQL(*Structured Query Language*)の説明

- DBの一貫性を保持するための各種制約条件の総称である  
整合性制約の説明

---
21.関係を第3正規形まで正規化して設計する目的

- A.**冗長性を排除することによって、更新時異状を回避する**  
正規化の目的は冗長性の排除をすることで更新時異状を回避し、DBの一貫性を確保すること

- 値の重複をなくすことによって、格納効率を向上させる  
重複の排除は第1正規化で実施される

- 関係を細かく分解することによって、整合性制約を排除する  
表が多くなるほど整合性制約は増加する

- 属性間の結合度を低下させることによって、更新時のロック待ちを減らす  
パフォーマンス向上のために行うわけではない。正規化を行うと表が幾つかに分割され、更新時には表の結合が行われる。表が分割されるほど結合処理も増加するのでロック待ちの減少には繋がらない

---
24.UMLを用いて表した図のデータモデルに対する多重度の説明

<img width="500" alt="" src="./images/多重度.png">

- A.**社員は同じプロジェクトに異なる役割分担で参画できる**  
プロジェクト参画のレコードは、プロジェクト・社員・プロジェクト内役割分担の3つのキーで決定される。プロジェクト参画に対するそれぞれの多重度は全て0以上なので、1社員が複数のプロジェクトに参画でき、同じプロジェクト内で異なる役割分担を担うことが許される

- 社員が複数のプロジェクトに参画する場合、全て同じ役割分担となる  
同じプロジェクトで異なる役割分担をすることができる

- 社員は1つ以上のプロジェクトに参画している  
社員から見たプロジェクト参画の多重度は0以上なので、1社員が参画するプロジェクト数は0以上になる

- 社員は複数の部門に所属できる  
社員から見た部門の多重度は1なので、社員が所属する部門数は常に1

---
25.ER図の説明

- A.**エンティティタイプ間には、1対多、多対多などのリレーションシップがある**  
DB化の対象となる実体(エンティティ)と実体の持つ属性(アトリビュート)、実体間の関連(リレーションシップ)を表現する図。任意のオブジェクトと関連をデータモデル化できるが、関係DBの設計においてよく使用される

- エンティティタイプ間の関連は、参照側から被参照側への方向の矢印線で表現する  
1対1、1対多、多対多という意味がある

- エンティティタイプには属性をもたせないで、リレーションシップタイプに属性をもたせる  
エンティティタイプは属性を持つ

- エンティティタイプの中に関連先のエンティティ名を記述することによって、リレーションシップを表す  
エンティティタイプ間を結ぶ矢印線で表す

---
28.UMLを用いて表した図のデータモデルの解釈  
納品(1..*) --- (0..1)請求

- A.**複数回の納品分をまとめて請求できる**  
1つ以上の納品が、0または1回の請求に対応している。納品に対して請求がない場合で、1回の請求が1つ以上の納品に対応することを考えると、複数回の納品分をまとめて請求できる

- 1回の納品に対して分割請求できる  
1納品に対して複数の請求が発生するので、1対1以上の関係になる

- 顧客への請求を支払いで相殺できる  
納品に対して請求が発生しない場合が存在するので、1対0(1)の関係になる

- 支払処理は納品と同時に実行される  
納品と請求が1対1で対応し、1対1の関係になる

---
31.DBMSが管理するデータ、利用者、プログラムに関する情報、それらの間の関係を保持するデータの集合体

- A.**データディクショナリ**  
DBやシステム開発においてデータの属性・性質などデータに関する情報の定義(メタデータ)を保存・管理するための辞書

- データウェアハウス  
企業内に散らばっているデータの有効活用を目的に、過去から現在までの基幹系DBや外部DBを整理・統合し効果的な戦略的意思決定を支援するためのDBのこと

- データマート  
データウェアハウスの中から特定の目的に合わせて、ある部分を取り出したり加工を施すなどした小規模なDB

- データマイニング  
データウェアハウスに蓄積されている大量の生データから、統計学的手法、数学的手法を用いて今まで知られていなかったデータの規則や因果関係を見つけ出す手法

---
32.次の"受注台帳"表を"注文"表と"顧客"表に分解し、第3正規系にした時、両方に必要な属性はどれか。送付先と支払方法は注文ごとに決めるものとし、表の下線は主キーを表す  
受注台帳(<u>注文番号</u>, 注文年月日,顧客ID, 顧客名, 顧客住所, 品目, 数量, 送付先, 支払方法, 受注金額)

- A.**顧客ID**  
`第1正規化` : 繰り返し項目、集合知をなくす  
`第2正規化` : 主キーの一部によって一意に決まる属性を別表に移す  
`第3正規化` : 主キー以外の属性によって一意に決まる属性を別表に移す  
主キーが第一属性なので第2正規形の条件を満たしている。"受注台帳"表の主キー以外の属性では、顧客ごとに固有の"顧客ID"から顧客名・顧客住所が一意に導ける。この関係を**顧客(<u>顧客ID</u>, 顧客名, 顧客住所)** の別表に移すが、表同士を関連付けるために"顧客ID"を"受注台帳"表に残したままにしなければならない。表同士がある属性で関連づけられていないと、分解前の表を完全な状態で復元できない。"受注台帳"表の属性"顧客ID"は、"顧客ID"を参照する外部キーとなる

---
33."発注伝票"表を第3正規形に書き換えたものはどれか。下線部は主キーを表す  
発注伝票(<u>注文番号</u>, <U>商品番号</u>, 商品名, 注文数量)

- A.**発注(<u>注文番号</u>, <u>商品番号</u>, 注文数量)**  
- A.**商品(<u>商品番号</u>, 商品名)**  
"発注伝票"表は、全ての属性が単一値なので第1正規系を満たすが、主キーの一部の"商品番号"に関数従属する"商品名"があるため第2正規系ではない。第2正規系にするには"商品番号"と、"商品番号"によって一意によって定まる"商品名"の関係を"商品"表として分離する。"発注伝票"表の中に外部キーとして"商品番号"の列を残し、分離した"商品"表とリレーションを形成する。第3正規化では主キー以外の属性に関数従属する属性があれば、その関係を別表に移すが条件を満たす関係が存在しないので条件を満たしている
