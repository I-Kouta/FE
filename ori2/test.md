### オリジナル模擬試験問題2

### `テクノロジ系`

---
1.次に示す手順は、列中の少なくとも1つは1であるビット列が与えられた時、最も右にある1を残し、他のビットを全て0にするアルゴリズムである。例えば、`00101000`が与えられた時、`00001000`が求まる。aに入る論理演算  
手順1 : 与えられたビット列Aを符号なしの2進数と見なし、Aから1を引き、結果をBとする  
手順2 : AとBの排他的論理和(XOR)と求め、結果をCとする  
手順3 : AとCの`a`を求め、結果をAとする

- A.**論理積(AND)**  
`00101000`(A)  
`00001111`(C) => 00001000

`00101000`(A)を処理する場合を想定する  
手順1 : 1を引くと、`00100111`(B)  
手順2 : `00101000` XOR `00100111` => `00001111`(C)  
手順3 : `00101000`(A)と`00001111`(C)を比較  
`00101000`(A)  
`00001111`(C)

- 排他的論理和(XOR)  
`00101000`(A)  
`00001111`(C) => 00100111

- 否定論理積(NAND)  
`00101000`(A)  
`00001111`(C) => 11110111

- 論理和(OR)  
`00101000`(A)  
`00001111`(C) => 00101111

---
2.XとYの否定論理積`X NAND Y`は、`NOT(X AND Y)`として定義される。`X OR Y`をNANDだけで表した論理式

- A.**(X NAND X) NAND (Y NAND Y)**  
X = Y = 0の場合、  
`(0 NAND 0) NAND (0 NAND 0)` = **0**  
X =1, Y = 0の場合、  
`(1 NAND 1) NAND (0 NAND 0)`  
= `0 NAND 1` = **1**

`X OR Y` : 論理和。X, Yの**どちらか一方でも1であれば1、全て0なら0**  
`X NAND Y`, `NOT(X AND Y)` : 1つでも0であれば1、全て1なら0

- `((X NAND Y) NAND X) NAND Y`  
X = Y = 0の場合、  
`((0 NAND 0) NAND 0) NAND 0`  
= `(1 NAND 0) NAND 0`  
= 1 NAND 0 = **1**  
X =1, Y = 0の場合、  
`((1 NAND 0) NAND 1) NAND 0`  
= `(1 NAND 1) NAND 0`  
= `0 NAND 0` = **1**

- `(X NAND Y) NAND (X NAND Y)`  
X = Y = 0の場合、  
`(0 NAND 0) NAND (0 NAND 0)`  
= `1 NAND 1` = **0**  
X =1, Y = 0の場合、  
`(1 NAND 0) NAND (1 NAND 0)`  
= `1 NAND 1` = **0**

- `X NAND (Y NAND (X NAND Y))`  
X = Y = 0の場合、  
`0 NAND (0 NAND (0 NAND 0))`  
= `0 NAND (0 NAND 1)`  
= `0 NAND 1` = **1**  
X =1, Y = 0の場合、  
`1 NAND (0 NAND (1 NAND 0))`  
= `1 NAND (0 NAND 1)`  
= `1 NAND 1` = **0**

<img width="400" alt="" src="./images/ベン図.png">

---
3.浮動小数点形式で表現された数値の演算結果における丸め誤差の説明

- A.**数表現のけた数に限度があるので、最下位けたより小さい部分について四捨五入や切上げ、切捨てを行うことによって生じる誤差である**

- 演算結果がコンピュータの扱える最大値を超えることによって生じる誤差である  
オーバーフローの説明

- 乗除算において、指数部が小さい方の数値の仮数部の下位部分が失われることによって生じる誤差である  
情報落ちの説明

- 絶対値がほぼ等しい数値の加減算において、上位の有効数字が失われることによって生じる誤差である  
けた落ちの説明

---
4.関数f(x)は、引数も戻り値も実数型である。この関数を使った1 ~ 5から成る手続を考える。手続の実行を開始してから十分な回数を繰り返した後、3で表示されるyの値に変化がなくなった。このとき成立する関係式  
1.x ← a  
2.y ← f(x)  
3.yの値を表示する  
4.x ← y  
5.2に戻る

- A.**f(y) = y**  
yの値が一定であるということは、十分な回数を繰り返すと、`y = f(x)`の関係が成立するということになる。2の処理のf(x)には、4の処理においてyが代入されていることが分かる  
4.x ←  y // x = y  
2.y ← f(x) // f(x) = f(y)  
3.yの値を表示する  
`f(x) = f(y)`となり、上記の式のf(x)はf(y)に置き換えることができるので、`y = f(y)`の関係式が成立しているといえる
