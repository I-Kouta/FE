### オリジナル模擬試験問題2

### `テクノロジ系`

---
1.次に示す手順は、列中の少なくとも1つは1であるビット列が与えられた時、最も右にある1を残し、他のビットを全て0にするアルゴリズムである。例えば、`00101000`が与えられた時、`00001000`が求まる。aに入る論理演算  
手順1 : 与えられたビット列Aを符号なしの2進数と見なし、Aから1を引き、結果をBとする  
手順2 : AとBの排他的論理和(XOR)と求め、結果をCとする  
手順3 : AとCの`a`を求め、結果をAとする

- A.**論理積(AND)**  
`00101000`(A)  
`00001111`(C) => 00001000

`00101000`(A)を処理する場合を想定する  
手順1 : 1を引くと、`00100111`(B)  
手順2 : `00101000` XOR `00100111` => `00001111`(C)  
手順3 : `00101000`(A)と`00001111`(C)を比較  
`00101000`(A)  
`00001111`(C)

- 排他的論理和(XOR)  
`00101000`(A)  
`00001111`(C) => 00100111

- 否定論理積(NAND)  
`00101000`(A)  
`00001111`(C) => 11110111

- 論理和(OR)  
`00101000`(A)  
`00001111`(C) => 00101111

---
2.XとYの否定論理積`X NAND Y`は、`NOT(X AND Y)`として定義される。`X OR Y`をNANDだけで表した論理式

- A.**(X NAND X) NAND (Y NAND Y)**  
X = Y = 0の場合、  
`(0 NAND 0) NAND (0 NAND 0)` = **0**  
X =1, Y = 0の場合、  
`(1 NAND 1) NAND (0 NAND 0)`  
= `0 NAND 1` = **1**

`X OR Y` : 論理和。X, Yの**どちらか一方でも1であれば1、全て0なら0**  
`X NAND Y`, `NOT(X AND Y)` : 1つでも0であれば1、全て1なら0

- `((X NAND Y) NAND X) NAND Y`  
X = Y = 0の場合、  
`((0 NAND 0) NAND 0) NAND 0`  
= `(1 NAND 0) NAND 0`  
= 1 NAND 0 = **1**  
X =1, Y = 0の場合、  
`((1 NAND 0) NAND 1) NAND 0`  
= `(1 NAND 1) NAND 0`  
= `0 NAND 0` = **1**

- `(X NAND Y) NAND (X NAND Y)`  
X = Y = 0の場合、  
`(0 NAND 0) NAND (0 NAND 0)`  
= `1 NAND 1` = **0**  
X =1, Y = 0の場合、  
`(1 NAND 0) NAND (1 NAND 0)`  
= `1 NAND 1` = **0**

- `X NAND (Y NAND (X NAND Y))`  
X = Y = 0の場合、  
`0 NAND (0 NAND (0 NAND 0))`  
= `0 NAND (0 NAND 1)`  
= `0 NAND 1` = **1**  
X =1, Y = 0の場合、  
`1 NAND (0 NAND (1 NAND 0))`  
= `1 NAND (0 NAND 1)`  
= `1 NAND 1` = **0**

<img width="400" alt="" src="./images/ベン図.png">

---
3.浮動小数点形式で表現された数値の演算結果における丸め誤差の説明

- A.**数表現のけた数に限度があるので、最下位けたより小さい部分について四捨五入や切上げ、切捨てを行うことによって生じる誤差である**

- 演算結果がコンピュータの扱える最大値を超えることによって生じる誤差である  
オーバーフローの説明

- 乗除算において、指数部が小さい方の数値の仮数部の下位部分が失われることによって生じる誤差である  
情報落ちの説明

- 絶対値がほぼ等しい数値の加減算において、上位の有効数字が失われることによって生じる誤差である  
けた落ちの説明
